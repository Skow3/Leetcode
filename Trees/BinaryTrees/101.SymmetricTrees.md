# EASY
* It was quite easy but i was doing some mistake in the recursion check part.
* Instead of checking the subtrees for each root at first i ended up checking the roots only.
* This question was similar to question which checked that if the two different trees are equal.
* Here is just treated the left side tree[OF MAIN ROOT] and right side tree[OF MAIN ROOT] as different trees.

# ISSUE 1 IN CODE:
```python
what about this?
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def isSymmetric(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: bool
        """
        def checker(p,q):
            if not p and not q:
                return True
            if not p and q:
                return False
            if p and not q:
                return False
            if p and q:
                if p.val==q.val:
                    return True
                else:
                    return False
            return checker(p.left,q.right) and checker(p.right,q.left)
        return checker(root.left,root.right)
```

# OPTIMIZED SOLUTION
```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def isSymmetric(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: bool
        """
        def checker(p,q):
            if not p and not q:
                return True
            if not p and q:
                return False
            if p and not q:
                return False
            if p.val!=q.val:
                return False
            return checker(p.left,q.right) and checker(p.right,q.left)
        return checker(root.left,root.right)
```


