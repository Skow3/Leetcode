# Shuffling an Array

# Solution 1:
```python
class Solution(object):
    def shuffle(self, nums, n):
        """
        :type nums: List[int]
        :type n: int
        :rtype: List[int]
        """
        num1= nums[0:n]
        num2= nums[n:2*n]
        ans=[]
        for i in range(n):
            ans.append(num1[i])
            ans.append(num2[i])
        return ans
```


# Solution in Cpp:
```cpp
class Solution {
public:
    vector<int> shuffle(vector<int>& nums, int n) {
        vector<int> ans;
        ans.reserve(2*n);
        for(int i=0;i<n;++i){
            ans.push_back(nums[i]);
            ans.push_back(nums[i+n]);
        }
        return ans;
    }
};
```

## Important points :
* What i was doing was i was initialising vector ans with (2*n) i.e ZEROES and then using push_back.
* That was absolutely wrong.
* The correct approach is what i did above:

  Also one major point of using reserve() in c++:
  ### What Happens Internally (Important)
- `ans` starts with **capacity = 0**
- First `push_back()`  
  → memory is allocated
- As elements are added and **capacity fills up**  
  → the vector **reallocates** to a larger block
- During reallocation  
  → **all existing elements are copied or moved** to the new memory
- This process **repeats multiple times** as the vector grows

### This Causes

- **Extra memory allocations**
- **Extra copying / moving of elements**
- **Slower runtime**, especially for large `n`
